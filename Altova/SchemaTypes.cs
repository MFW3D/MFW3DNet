//
// SchemaTypes.cs
//
// This file was generated by XMLSpy 2005 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//


using System;
using System.Globalization;
using Altova;


namespace Altova.Types
{
	#region Interfaces
	/// <summary>
	/// Common interface for all schema-types.
	/// </summary>
	public interface ISchemaType : IComparable, ICloneable
	{
		bool BoolValue(); // returns the value as bool if possible, otherwise false.
		bool IsEmpty();
		void SetEmpty( bool bIsEmpty );
		bool IsNull();
		void SetNull( bool bIsNull );
		

	}

	/// <summary>
	/// Interface for all schema-types containing (or may contain) numeric values.
	/// Used for type-casts.
	/// </summary>
	public enum ENumericTypes { ValueInt=1, ValueLong, ValueDouble, ValueDecimal };
	public interface ISchemaTypeNumber : ISchemaType 
	{
		ENumericTypes NumericType(); // returns if the value is nummeric and up to which degree.

		int IntValue();
		long LongValue();
		double DoubleValue();
		decimal DecimalValue();
	}

	/// <summary>
	/// Interface for all schema-types containing (or may contain) date/time/dateTime or duration values.
	/// </summary>
	public enum ECalendarTypes { Undefined=-1, Duration=0, DateTime, Date, Time };
	public interface ISchemaTypeCalendar : ISchemaType
	{
		ECalendarTypes CalendarType();

		SchemaDuration DurationValue();
		SchemaDateTime DateTimeValue();
		SchemaDate DateValue();
		SchemaTime TimeValue();
	}

	/// <summary>
	/// Interface for all schema-types containing (or may contain) binary values.
	/// Used for type-casts.
	/// </summary>
	public enum EBinaryTypes { Base64=1, Hex };
	public interface ISchemaTypeBinary : ISchemaType 
	{
		EBinaryTypes BinaryType(); // returns if the value is binary and to which base.
	}
	#endregion //Interfaces

	#region Base classes
	/// <summary>
	/// Common base-class for all schema-types containing date/time/dateTime values
	/// </summary>
	public abstract class SchemaCalendarBase : ISchemaTypeCalendar
	{
		public enum ETZ { Missing, UTC, Offset };

		protected DateTime myValue;
		protected ETZ eTZ;
		protected int offsetTZ; // offset in minutes
		protected bool isEmpty;
		protected bool isNull;

		#region Constructors
		public SchemaCalendarBase() 
		{
			Reset();
			isEmpty = true;
			isNull = false;
			eTZ = ETZ.Missing;
		}

		public SchemaCalendarBase(SchemaCalendarBase obj)
		{
			myValue = obj.myValue;
			eTZ = obj.eTZ;
			offsetTZ = obj.offsetTZ;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaCalendarBase(DateTime newvalue)
		{
			myValue = newvalue;
			eTZ = ETZ.Missing;
			offsetTZ = 0;
			isEmpty = false;
			isNull = false;
		}

		public SchemaCalendarBase(int year, int month, int day, int hour, int minute, int second, double newpartsecond, bool newhasTZ, int newoffsetTZ)
		{
			myValue = new DateTime(year, month, day, hour, minute, second, (int)(newpartsecond*1000) );
			eTZ = newhasTZ ? ( newoffsetTZ == 0 ? ETZ.UTC : ETZ.Offset ) : ETZ.Missing;
			offsetTZ = newoffsetTZ;
			isEmpty = false;
			isNull = false;
		}

		#endregion //Constructors

		#region Get, Set
		public DateTime Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = false;
			}
		}

		public ETZ HasTimezone
		{
			get
			{
				return eTZ;
			}
			set
			{
				eTZ = value;
				isEmpty = false;
			}
		}

		public int TimezoneOffset
		{
			get
			{
				return offsetTZ;
			}
			set
			{
				offsetTZ = value;
				eTZ = (offsetTZ != 0) ? ETZ.Offset : ETZ.UTC;
				isEmpty = false;
			}
		}

		#endregion //Get, Set

		#region implemented Interfaces
		// System.IComparable
		public override bool Equals(object obj) 
		{
			if (! (obj is SchemaCalendarBase))
				return false;
			SchemaCalendarBase dt = (SchemaCalendarBase)obj;
			if( myValue.CompareTo(dt.myValue)!=0 )
				return false;
			if( !(eTZ == dt.eTZ) )
				return false;
			if( !(offsetTZ == dt.offsetTZ) )
				return false;
			return true;
		}

		public override int GetHashCode()
		{
			return myValue.GetHashCode();
		}

		public int CompareTo(object obj)
		{
			return CompareTo( (SchemaCalendarBase)obj );
		}

		public int CompareTo(SchemaCalendarBase obj)
		{
			DateTime a = GetDateTime( true );
			DateTime b = obj.GetDateTime( true );
			return a.CompareTo( b );
		}

		// ISchemaType
		public bool BoolValue() 
		{
			return true;
		}

		public bool IsEmpty()
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
			if( bIsEmpty )
				myValue = DateTime.Now;
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
			if( bIsNull )
				SetEmpty( true );
		}

		// ISchemaTypeCalendar
		public SchemaDuration DurationValue()
		{
			throw new TypesIncompatibleException(this, new SchemaDuration( "PT" ) );
		}
		#endregion //Implemented interfaces

		#region Utility functions
		public string ToDateString() 
		{
			string s = "";
			s += myValue.Year.ToString("0000");
			s += "-";
			s += myValue.Month.ToString("00");
			s += "-";
			s += myValue.Day.ToString("00");
			return s;
		}

		public string ToTimeString() 
		{
			string s = "";
			s += myValue.Hour.ToString("00");
			s += ":";
			s += myValue.Minute.ToString("00");
			s += ":";
			s += myValue.Second.ToString("00");
			double partsecond = (double)myValue.Millisecond / 1000.0;
			if( partsecond > 0 && partsecond < 1) 
			{
				string sPartSecond = partsecond.ToString("0.0###############");
				s += ".";
				s += sPartSecond.Substring( 2, sPartSecond.Length-2 );
			}
			if( eTZ == ETZ.UTC )
			{
				s += "Z";
			}
			else if( eTZ == ETZ.Offset ) 
			{
				int absOffsetTZ = offsetTZ;
				if (offsetTZ < 0) 
				{
					s += "-";
					absOffsetTZ = -offsetTZ;
				}
				else
					s += "+";
				s += ((int)(absOffsetTZ / 60)).ToString("00");
				s += ":";
				s += ((int)(absOffsetTZ % 60)).ToString("00");
			}
			return s;
		}

		protected void ParseDate(string newvalue) //throws StringParseException 
		{
			if (newvalue.Length < 10)
				throw new StringParseException("date-part of string is too short", 0);
			try 
			{
				int nStart = 0;
				if( newvalue.Substring(0,1).Equals("-") )
					nStart = 1;
				int year = Convert.ToInt32(newvalue.Substring(0, 4));
				if( !newvalue.Substring(nStart+4, 1).Equals("-"))
					throw new StringParseException("invalid date format", 2);
				int month = Convert.ToInt32(newvalue.Substring(nStart+5, 2));
				if( !newvalue.Substring(nStart+7, 1).Equals("-"))
					throw new StringParseException("invalid date format", 2);
				int day = Convert.ToInt32(newvalue.Substring(nStart+8, newvalue.Length-nStart-8));
				myValue = new DateTime( year, month, day, myValue.Hour, myValue.Minute, myValue.Second, myValue.Millisecond);
			}
			catch (FormatException) 
			{
				throw new StringParseException("invalid date format", 2);
			}
			isEmpty = false;
		}

		protected void ParseTime(string newvalue) //throws StringParseException 
		{
			if (newvalue.Length < 8)
				throw new StringParseException("time-part of string is too short", 0);
			try 
			{
				int nStart = 0;
				int hour = Convert.ToInt32(newvalue.Substring(nStart, 2));
				if( !newvalue.Substring(nStart+2, 1).Equals(":"))
					throw new StringParseException("invalid date format", 2);
				int minute = Convert.ToInt32(newvalue.Substring(nStart+3, 2));
				if( !newvalue.Substring(nStart+5, 1).Equals(":"))
					throw new StringParseException("invalid date format", 2);
				int second = Convert.ToInt32(newvalue.Substring(nStart+6, 2));
				int nTZStartPosition = nStart+8;
				double partsecond = 0.0;
				if (newvalue.Length>(nStart+8)  &&  newvalue.Substring(nStart+8, 1).Equals(".") ) 
				{
					nStart = nTZStartPosition+1;
					int nEnd = newvalue.Length;
					int nMSecEnd = newvalue.IndexOf("Z", nStart);
					if( nMSecEnd > -1  &&  nMSecEnd < nEnd )
						nEnd = nMSecEnd;
					nMSecEnd = newvalue.IndexOf("+", nStart);
					if( nMSecEnd > -1  &&  nMSecEnd < nEnd )
						nEnd = nMSecEnd;
					nMSecEnd = newvalue.IndexOf("-", nStart);
					if( nMSecEnd > -1  &&  nMSecEnd < nEnd )
						nEnd = nMSecEnd;
					nTZStartPosition = nEnd;
					partsecond = Convert.ToDouble( "0." + newvalue.Substring(nStart, nEnd-nStart), CultureInfo.InvariantCulture);
				}
				eTZ = ETZ.Missing;
				offsetTZ = 0;
				if (newvalue.Length>nTZStartPosition && newvalue.Substring(nTZStartPosition, 1).Equals("Z"))
					eTZ = ETZ.UTC;
				else if (newvalue.Length == nTZStartPosition + 6) 
				{
					eTZ = ETZ.Offset;
					offsetTZ = Convert.ToInt32(newvalue.Substring(nTZStartPosition+1, 2)) * 60 +
						Convert.ToInt32(newvalue.Substring(nTZStartPosition+4, 2));
					if( newvalue.Substring(nTZStartPosition, 1).Equals("-"))
						offsetTZ = -offsetTZ;
				}
				myValue = new DateTime( myValue.Year, myValue.Month, myValue.Day, hour, minute, second, (int)(partsecond * 1000.0));
			}
			catch (FormatException) 
			{
				throw new StringParseException("invalid number format", 2);
			}
			isEmpty = false;
		}

		public DateTime GetDateTime(bool correctTZ) 
		{
			DateTime result = myValue;
			if( correctTZ && eTZ == ETZ.Offset )
				result.AddMinutes( offsetTZ );

			return	result;
		}

		public void Reset()
		{
			myValue = DateTime.Now;
			eTZ = ETZ.Missing;
			offsetTZ = 0;
		}

		#endregion //Utility functions

		#region Abstract interfaces
		

		// ISchemaTypeCalendar
		public abstract ECalendarTypes CalendarType();
		public abstract SchemaDateTime DateTimeValue();
		public abstract SchemaDate DateValue();
		public abstract SchemaTime TimeValue();
		// System.ICloneable
		public abstract object Clone();
		#endregion //Abstract interfaces

	}

	/// <summary>
	/// Common base-class for all schema-types containing binary values
	/// </summary>
	public abstract class SchemaBinaryBase : ISchemaTypeBinary
	{
		protected byte[] myValue;
		protected bool isEmpty;
		protected bool isNull;

		#region Constructors
		public SchemaBinaryBase() 
		{
			isEmpty = true;
			isNull = false;
		}

		public SchemaBinaryBase(SchemaBinaryBase obj)
		{
			myValue = obj.myValue;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaBinaryBase(byte[] newvalue)
		{
			myValue = newvalue;
			isEmpty = false;
			isNull = false;
		}





		#endregion //Constructors

		#region Get, Set
		public byte[] Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = false;
			}
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null )
			{
				SetNull(true);
				return;
			}

			if( newvalue.IsEmpty() )
			{
				SetEmpty(true);
				return;
			}

			if( newvalue is SchemaBinaryBase )
			{
				SchemaBinaryBase obj = ((SchemaBinaryBase)newvalue);
				myValue = obj.Value;
				isEmpty = obj.IsEmpty();
			}
			else if( newvalue is SchemaString )
				Parse( newvalue.ToString() );
			else
				throw new TypesIncompatibleException( newvalue, this );
		}

		#endregion //Get, Set

		#region implemented Interfaces
		// System.IComparable
		public override bool Equals(object obj) 
		{
			if (! (obj is SchemaBinaryBase))
				return false;
			SchemaBinaryBase data = (SchemaBinaryBase)obj;
			if( myValue.Length != data.Value.Length )
				return false;
			for( long l = 0; l < myValue.Length; l++ )
				if( myValue[l] != data.Value[l] )
					return false;
			return true;
		}

		public override int GetHashCode()
		{
			if( myValue.Length > 0 )
				return myValue[0].GetHashCode();
			return 1243;
		}

		public int CompareTo(object obj)
		{
			return CompareTo( (SchemaBinaryBase)obj );
		}

		public int CompareTo(SchemaBinaryBase obj)
		{
			long l = 0;
			while( l < myValue.Length && l < obj.Value.Length && myValue[l]==obj.Value[l] )
				l++;
			if( l < myValue.Length && l < obj.Value.Length )
				return myValue[l].CompareTo( obj.Value[l] );
			return myValue.Length.CompareTo( obj.Value.Length );
		}



		// ISchemaType
		public bool BoolValue() 
		{
			return true;
		}

		public bool IsEmpty() 
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
		}

		#endregion //Implemented interfaces

		#region Abstract interfaces
		public abstract void Parse( string newvalue );

		// ISchemaTypeBinary
		public abstract EBinaryTypes BinaryType();

		// System.ICloneable
		public abstract object Clone();
		#endregion //Abstract interfaces
	}
	#endregion //Base classes
	class FormatSpecifiers
	{
		public readonly static string DecimalNumberFormat= "###############################0.#############################";
	}
	#region Schema types
	public class SchemaBoolean : ISchemaTypeNumber
	{
		protected bool myValue = false;
		protected bool isEmpty = true;
		protected bool isNull = true;

		#region Constructors
		public SchemaBoolean()
		{
			isNull = false;
		}

		public SchemaBoolean(SchemaBoolean obj)
		{
			myValue = obj.Value;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaBoolean(bool newvalue)
		{
			this.myValue = newvalue;
			this.isEmpty = false;
			this.isNull = false;
		}

		public SchemaBoolean(string newvalue)
		{
			Parse( newvalue );
		}
		public SchemaBoolean(ISchemaType newvalue)
		{
			Assign(newvalue);
		}


		#endregion //Constructors

		#region Get, Set
		public bool Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = false;
				isNull = false;
			}
		}

		public void Parse(string newvalue)
		{
			if( newvalue == null ) 
			{
				isEmpty = true;
				myValue = false;
				isNull = true;
				return;
			}
			if( newvalue.Length > 0 )
			{
				myValue = new SchemaString(newvalue).BoolValue();
				isEmpty = false;
				isNull = false;
			}
			else
			{
				isEmpty = true;
				isNull = false;
			}
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null )
			{
				SetNull(true);
				return;
			}

			if( newvalue.IsEmpty() )
			{
				SetEmpty(true);
				return;
			}

			Parse(newvalue.ToString());
		}
		#endregion //Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return Value ? "true" : "false";	// when converting to an string-value, than XML-Schema would expect "" for false.
		}


		#region Implemented interfaces
		// System.IComparable
		public override int GetHashCode()
		{
			return Value ? 1231 : 1237;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			if (!(obj is SchemaBoolean))
				return false;
			return Value == ((SchemaBoolean)obj).Value;
		}

		public static bool operator==(SchemaBoolean obj1, SchemaBoolean obj2)
		{
			return obj1.BoolValue() == obj2.BoolValue();
		}

		public static bool operator!=(SchemaBoolean obj1, SchemaBoolean obj2)
		{
			return obj1.BoolValue() != obj2.BoolValue();
		}

		public int CompareTo(object obj)
		{
			return Value.CompareTo(((SchemaBoolean)obj).Value);
		}

		// System.ICloneable
		public object Clone()
		{
			return new SchemaBoolean(Value);
		}
		// ISchemaType
		public bool IsEmpty()
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
			if( bIsEmpty )
			{
				myValue = false;
			}
			else
			{
				isNull = false;
			}
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
			if( bIsNull )
				SetEmpty(true);
		}
		
		public bool BoolValue()
		{
			return myValue;
		}


		// ISchemaTypeNumber
		public ENumericTypes NumericType()
		{
			return ENumericTypes.ValueInt;
		}

		public int IntValue()
		{
			return myValue ? 1 : 0;
		}

		public long LongValue()
		{
			return myValue ? 1 : 0;
		}

		public double DoubleValue()
		{
			return myValue ? 1.0 : 0;
		}

		public decimal DecimalValue()
		{
			return myValue ? (decimal)1 : (decimal)0;
		}

		#endregion //Implemented interfaces
	}

	public class SchemaInt : ISchemaTypeNumber
	{
		protected int myValue = 0;
		protected bool isEmpty = true;
		protected bool isNull = true;

		#region Constructors
		public SchemaInt()
		{
			isNull = false;
		}

		public SchemaInt(SchemaInt obj)
		{
			myValue = obj.myValue;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaInt(int newvalue)
		{
			myValue = newvalue;
			isEmpty = false;
			isNull = false;
		}

		public SchemaInt(string newvalue)
		{
			Parse( newvalue );
		}

		public SchemaInt(ISchemaType newvalue)
		{
			Assign( newvalue );
		}



		#endregion //Constructors

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return myValue.ToString();
		}


		#region Get, Set
		public int Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = false;
				isNull = false;
			}
		}

		public void Parse(string newvalue)
		{
			if( newvalue == null  || newvalue == "" )
			{
				myValue = 0;
				isEmpty = true;
				isNull = true;
				return;
			}
			try
			{
				myValue = Convert.ToInt32(newvalue);
				isEmpty = false;
				isNull = false;
			}
			catch( FormatException e )
			{
				throw new StringParseException(e);
			}
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null )
			{
				SetNull( true );
				return;
			}
			if( newvalue.IsEmpty() )
			{
				SetEmpty( true );
			}
				
			
			if( newvalue == null || newvalue.IsEmpty() )
			{
				myValue = 0;
				isEmpty = true;
				isNull = true;
				return;
			}
			if( newvalue is ISchemaTypeNumber )
			{
				isEmpty = false;
				isNull = false;
				myValue = ((ISchemaTypeNumber)newvalue).IntValue();
			}
			else
				throw new TypesIncompatibleException(newvalue, this);
		}

		#endregion //Get, Set

		#region Implemented interfaces
		// System.IComparable
		public override int GetHashCode()
		{
			return Value;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			if (!(obj is SchemaInt))
				return false;
			return Value == ((SchemaInt)obj).Value;
		}

		public static bool operator==(SchemaInt obj1, SchemaInt obj2)
		{
			return obj1.Value == obj2.Value;
		}

		public static bool operator!=(SchemaInt obj1, SchemaInt obj2)
		{
			return obj1.Value != obj2.Value;
		}

		public int CompareTo(object obj)
		{
			return Value.CompareTo(((SchemaInt)obj).Value);
		}

		// System.ICloneable
		public object Clone()
		{
			return new SchemaInt(Value);
		}
		// ISchemaType
		public bool BoolValue()
		{
			return myValue != 0;
		}

		public bool IsEmpty()
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
			if( bIsEmpty )
				myValue = 0;
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
			if( bIsNull )
				SetEmpty( true );
		}
		

		// ISchemaTypeNumber
		public ENumericTypes NumericType()
		{
			return ENumericTypes.ValueInt;
		}

		public int IntValue()
		{
			return myValue;
		}

		public long LongValue()
		{
			return myValue;
		}

		public double DoubleValue()
		{
			return myValue;
		}

		public decimal DecimalValue()
		{
			return myValue;
		}

		#endregion //Implemented interfaces
	}

	public class SchemaLong : ISchemaTypeNumber
	{
		protected long myValue = 0;
		protected bool isEmpty = true;
		protected bool isNull = true;

		#region Constructors
		public SchemaLong()
		{
			isNull = false;
		}

		public SchemaLong(SchemaLong obj)
		{
			myValue = obj.myValue;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaLong(long newvalue)
		{
			myValue = newvalue;
			isEmpty = false;
			isNull = false;
		}

		public SchemaLong(string newvalue)
		{
			Parse( newvalue );
		}

		public SchemaLong(ISchemaType newvalue)
		{
			Assign( newvalue );
		}



		#endregion //Constructors

		#region Get, Set
		public long Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = false;
				isNull = false;
			}
		}

		public void Parse(string newvalue)
		{
			if( newvalue == null  || newvalue == "" )
			{
				myValue = 0;
				isEmpty = true;
				isNull = true;
				return;
			}
			try
			{
				myValue = Convert.ToInt64(newvalue);
				isEmpty = false;
				isNull = false;
			}
			catch(FormatException e)
			{
				throw new StringParseException(e);
			}
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null || newvalue.IsEmpty() )
			{
				myValue = 0;
				isEmpty = true;
				isNull = true;
				return;
			}
			if( newvalue is ISchemaTypeNumber )
			{
				isEmpty = false;
				isNull = false;
				myValue = ((ISchemaTypeNumber)newvalue).LongValue();
			}
			else
				throw new TypesIncompatibleException(newvalue, this);
		}

		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return myValue.ToString();
		}

		#region Implemented interfaces
		// System.IComparable
		public override int GetHashCode()
		{
			return (int)Value;
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			if (!(obj is SchemaLong))
				return false;
			return Value == ((SchemaLong)obj).Value;
		}

		public static bool operator==(SchemaLong obj1, SchemaLong obj2)
		{
			return obj1.Value == obj2.Value;
		}

		public static bool operator!=(SchemaLong obj1, SchemaLong obj2)
		{
			return obj1.Value != obj2.Value;
		}

		public int CompareTo(object obj)
		{
			return Value.CompareTo(((SchemaLong)obj).Value);
		}

		// System.ICloneable
		public object Clone()
		{
			return new SchemaLong(Value);
		}

		// ISchemaType
		public bool BoolValue()
		{
			return myValue != 0;
		}

		public bool IsEmpty()
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
			if( bIsEmpty )
				myValue = 0;
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
			if( bIsNull )
				SetEmpty( true );
		}
		

		// ISchemaTypeNumber
		public ENumericTypes NumericType()
		{
			return ENumericTypes.ValueLong;
		}

		public int IntValue()
		{
			return (int)myValue;
		}

		public long LongValue()
		{
			return myValue;
		}

		public double DoubleValue()
		{
			return myValue;
		}

		public decimal DecimalValue()
		{
			return myValue;
		}

		#endregion // Implemented interfaces
	}

	public class SchemaDouble : ISchemaTypeNumber
	{
		protected double myValue = 0.0;
		protected bool isEmpty = true;
		protected bool isNull = true;

		#region Constructors
		public SchemaDouble()
		{
			isNull = false;
		}

		public SchemaDouble(SchemaDouble obj)
		{
			myValue = obj.myValue;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaDouble(double newvalue)
		{
			myValue = (double)newvalue;
			isEmpty = false;
			isNull = false;
		}

		public SchemaDouble(int newvalue)
		{
			myValue = (double)newvalue;
			isEmpty = false;
			isNull = false;
		}

		public SchemaDouble(string newvalue)
		{
			Parse(newvalue);
		}

		public SchemaDouble(ISchemaType obj)
		{
			Assign( obj );
		}


		#endregion //Constructors

		#region Get, Set
		public double Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = false;
				isNull = false;
			}
		}

		public void Parse(string newvalue)
		{
			if( newvalue == null  ||  newvalue == "" )
			{
				myValue = 0;
				isEmpty = true;
				isNull = true;
				return;
			}
			try
			{
				myValue = Convert.ToDouble(newvalue, CultureInfo.InvariantCulture );
				isEmpty = false;
				isNull = false;
			}
			catch( FormatException e )
			{
				throw new StringParseException(e);
			}
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null || newvalue.IsEmpty() )
			{
				myValue = 0;
				isEmpty = true;
				isNull = true;
				return;
			}
			if( newvalue is ISchemaTypeNumber )
			{
				isEmpty = false;
				isNull = false;
				myValue = ((ISchemaTypeNumber)newvalue).DoubleValue();
			}
			else
				throw new TypesIncompatibleException(newvalue, this);
		}

		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return myValue.ToString(FormatSpecifiers.DecimalNumberFormat, CultureInfo.InvariantCulture);
		}

		#region Implemented interfaces
		// System.IComparable
		public override int GetHashCode()
		{
			return myValue.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			if (!(obj is SchemaDouble))
				return false;
			return Value == ((SchemaDouble)obj).Value;
		}

		public static bool operator==(SchemaDouble obj1, SchemaDouble obj2)
		{
			return obj1.Value == obj2.Value;
		}

		public static bool operator!=(SchemaDouble obj1, SchemaDouble obj2)
		{
			return obj1.Value != obj2.Value;
		}

		public int CompareTo(object obj)
		{
			return Value.CompareTo(((SchemaDouble)obj).Value);
		}

		// System.ICloneable
		public object Clone()
		{
			return new SchemaDouble(Value);
		}

		// ISchemaType
		public bool BoolValue()
		{
			return myValue != 0.0;
		}

		public bool IsEmpty()
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
			if( bIsEmpty )
				myValue = 0.0;
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
			if( bIsNull )
				SetEmpty( true );
		}
		

		// ISchemaTypeNumber
		public ENumericTypes NumericType()
		{
			return ENumericTypes.ValueDouble;
		}

		public int IntValue()
		{
			return (int)myValue;
		}

		public long LongValue()
		{
			return (long)myValue;
		}

		public double DoubleValue()
		{
			return myValue;
		}

		public decimal DecimalValue()
		{
			return Convert.ToDecimal(myValue, CultureInfo.InvariantCulture);
		}

		#endregion // Implemented interfaces
	}

	public class SchemaDecimal : ISchemaTypeNumber
	{
		protected decimal myValue = 0M;
		protected bool isEmpty = true;
		protected bool isNull = true;

		#region Constructors
		public SchemaDecimal()
		{
			isNull = false;
		}

		public SchemaDecimal(SchemaDecimal obj)
		{
			myValue = obj.myValue;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaDecimal(decimal newvalue)
		{
			myValue = newvalue;
			isEmpty = false;
			isNull = false;
		}

		public SchemaDecimal(double newvalue)
		{
			myValue = (decimal)newvalue;
			isEmpty = false;
			isNull = false;
		}

		public SchemaDecimal(int newvalue)
		{
			myValue = (decimal)newvalue;
			isEmpty = false;
			isNull = false;
		}

		public SchemaDecimal(string newvalue)
		{
			Parse(newvalue);
		}

		public SchemaDecimal(ISchemaType obj)
		{
			Assign( obj );
		}

		#endregion //Constructors

		#region Get, Set
		public decimal Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = false;
				isNull = false;
			}
		}

		public void Parse(string newvalue)
		{
			if( newvalue == null  ||  newvalue == "" )
			{
				myValue = 0;
				isEmpty = true;
				isNull = true;
				return;
			}
			try
			{
				myValue = Convert.ToDecimal(newvalue, CultureInfo.InvariantCulture);
				isEmpty = false;
				isNull = false;
			}
			catch( FormatException e )
			{
				throw new StringParseException(e);
			}
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null || newvalue.IsEmpty() )
			{
				myValue = 0;
				isEmpty = true;
				isNull = true;
				return;
			}
			if( newvalue is ISchemaTypeNumber )
			{
				isEmpty = false;
				isNull = false;
				myValue = ((ISchemaTypeNumber)newvalue).DecimalValue();
			}
			else
				throw new TypesIncompatibleException(newvalue, this);
		}

		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return myValue.ToString(FormatSpecifiers.DecimalNumberFormat, CultureInfo.InvariantCulture);
		}

		#region Implemented interfaces
		// System.IComparable
		public override int GetHashCode()
		{
			return Value.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			if (!(obj is SchemaDecimal))
				return false;
			return Value == ((SchemaDecimal)obj).Value;
		}

		public static bool operator==(SchemaDecimal obj1, SchemaDecimal obj2)
		{
			return obj1.Value == obj2.Value;
		}

		public static bool operator!=(SchemaDecimal obj1, SchemaDecimal obj2)
		{
			return obj1.Value != obj2.Value;
		}

		public int CompareTo(object obj)
		{
			return Value.CompareTo(((SchemaDecimal)obj).Value);
		}

		// System.ICloneable
		public object Clone()
		{
			return new SchemaDecimal(Value);
		}

		// ISchemaType
		public bool BoolValue()
		{
			return myValue != 0M;
		}

		public bool IsEmpty()
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
			if( bIsEmpty )
				myValue = 0M;
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
			if( bIsNull )
				SetEmpty( true );
		}
		

		// ISchemaTypeNumber
		public ENumericTypes NumericType()
		{
			return ENumericTypes.ValueDecimal;
		}

		public int IntValue()
		{
			return (int)myValue;
		}

		public long LongValue()
		{
			return (long)myValue;
		}

		public double DoubleValue()
		{
			return Convert.ToDouble(myValue);
		}

		public decimal DecimalValue()
		{
			return myValue;
		}

		#endregion // Implemented interfaces
	}

	public class SchemaDateTime : SchemaCalendarBase
	{
		#region Constructors
		public SchemaDateTime()
			: base()
		{
		}

		public SchemaDateTime(SchemaDateTime obj)
			: base( (SchemaCalendarBase)obj )
		{
		}

		public SchemaDateTime(DateTime Value)
			: base( Value )
		{
		}

		public SchemaDateTime(int newyear, int newmonth, int newday, int newhour, int newminute, int newsecond, double newpartsecond, int newoffsetTZ )
		{
			myValue = new DateTime(newyear, newmonth, newday, newhour, newminute, newsecond, (int)(newpartsecond * 1000.0));
			eTZ =  ETZ.Offset;
			offsetTZ = newoffsetTZ;
			isEmpty = false;
			isNull = false;
		}

		public SchemaDateTime(int newyear, int newmonth, int newday, int newhour, int newminute, int newsecond, double newpartsecond )
		{
			myValue = new DateTime(newyear, newmonth, newday, newhour, newminute, newsecond, (int)(newpartsecond * 1000.0));
			eTZ = ETZ.Missing;
			offsetTZ = 0;
			isEmpty = false;
			isNull = false;
		}

		public SchemaDateTime(int newyear, int newmonth, int newday)
		{
			myValue = new DateTime(newyear, newmonth, newday);
			eTZ = ETZ.Missing;
			offsetTZ = 0;
			isEmpty = false;
			isNull = false;
		}

		public SchemaDateTime(string newvalue)
		{
			Parse( newvalue );
		}

		public SchemaDateTime(ISchemaType obj)
		{
			Assign( obj );
		}

		#endregion //Constructors;

		#region Get, Set
		public void Parse( string newvalue )
		{
			if (newvalue.Length < 19)
				throw new StringParseException(newvalue + " cannot be converted to a dateTime value", 0);
			try 
			{
				int nStart = newvalue.IndexOf("T");
				if (nStart == -1) 
				{
					nStart = newvalue.Length;
				}
				ParseDate( newvalue.Substring(0,nStart) );
				if( nStart < newvalue.Length )
					ParseTime( newvalue.Substring(nStart+1, newvalue.Length - nStart - 1 ));
				else 
				{
					myValue = new DateTime( myValue.Year, myValue.Month, myValue.Day, 0,0,0,0);
					eTZ = ETZ.Missing;
					offsetTZ = 0;
				}
			}
			catch (FormatException) 
			{
				throw new StringParseException(newvalue + " cannot be converted to a dateTime value", 2);
			}
			isEmpty = false;
			isNull = false;
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null || newvalue.IsEmpty() ) 
			{
				Value = DateTime.Now; // actual date and time
				isEmpty = true;
				isNull = true;
				return;
			}
			if( newvalue is SchemaDateTime )
			{
				SchemaDateTime dt = ((SchemaDateTime)newvalue);
				myValue = dt.myValue;
				eTZ = dt.eTZ;
				offsetTZ = dt.offsetTZ;
				isEmpty = dt.isEmpty;
				isNull = dt.isNull;
			}
			else if( newvalue is SchemaDate )
			{
				DateTime dt = ((SchemaDate)newvalue).Value;
				myValue = new DateTime( dt.Year, dt.Month, dt.Day, 0, 0, 0);
				eTZ = ETZ.Missing;
				offsetTZ = 0;
				isEmpty = newvalue.IsEmpty();
				isNull = newvalue.IsNull();
			}
			else if( newvalue is SchemaString )
				Parse( newvalue.ToString() );
			else
				throw new TypesIncompatibleException( newvalue, this );
		}

		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return ToDateString() + "T" + ToTimeString();
		}

		public static SchemaDateTime Now
		{
			get
			{
				return new SchemaDateTime( DateTime.Now );
			}
		}

		#region Implemented interfaces
		// ISchemaType

		// System.ICloneable
		public override object Clone()
		{
			return new SchemaDateTime(this);
		}

		// SchemaCalendarBase
		public override ECalendarTypes CalendarType()
		{
			return ECalendarTypes.DateTime;
		}

		public override SchemaDateTime DateTimeValue()
		{
			return (SchemaDateTime)Clone();
		}

		public override SchemaDate DateValue()
		{
			return new SchemaDate( myValue.Year, myValue.Month, myValue.Day );
		}

		public override SchemaTime TimeValue()
		{
			if( eTZ == ETZ.Offset )
				return new SchemaTime( myValue.Hour, myValue.Minute, myValue.Second, (double)myValue.Millisecond / 1000.0, offsetTZ );
			return new SchemaTime( myValue.Hour, myValue.Minute, myValue.Second, (double)myValue.Millisecond / 1000.0 );
		}


		#endregion Implemented interfaces
	}

	public class SchemaDate : SchemaCalendarBase
	{
		#region Constructors
		public SchemaDate()
			: base()
		{
			myValue = new DateTime(myValue.Year, myValue.Month, myValue.Day);	// set time to 0
		}

		public SchemaDate( SchemaDate obj )
			: base( (SchemaCalendarBase)obj )
		{
			myValue = new DateTime(myValue.Year, myValue.Month, myValue.Day);	// set time to 0
		}

		public SchemaDate( DateTime newvalue )
			: base( newvalue.Year, newvalue.Month, newvalue.Day, 0,0,0,0.0, false, 0 )
		{
		}

		public SchemaDate(int newyear, int newmonth, int newday)
			: base( newyear, newmonth, newday, 0,0,0,0.0, false, 0 )
		{
			isEmpty = false;
			isNull = false;
		}

		public SchemaDate(string newvalue)
		{
			Parse( newvalue );
		}

		public SchemaDate(ISchemaType obj)
		{
			Assign( obj );
		}

		#endregion // Constructors

		#region Get, Set
		public void Parse(string newvalue)
		{
			if( newvalue==null )
			{
				Reset();
				isEmpty = true;
				isNull = true;
				return;
			}
			ParseDate( newvalue );
			myValue = new DateTime( myValue.Year, myValue.Month, myValue.Day);
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null || newvalue.IsEmpty() ) 
			{
				Reset();
				isEmpty = true;
				isNull = true;
				return;
			}
			isEmpty = false;
			isNull = true;
			if( newvalue is SchemaDate ) 
			{
				DateTime dt = ((SchemaDate)newvalue).Value;
				myValue = new DateTime( dt.Year, dt.Month, dt.Day );
				eTZ = ETZ.Missing;
				offsetTZ = 0;
			}
			else if( newvalue is SchemaDateTime ) 
			{
				DateTime dt = ((SchemaDateTime)newvalue).Value;
				myValue = new DateTime( dt.Year, dt.Month, dt.Day );
				eTZ = ETZ.Missing;
				offsetTZ = 0;
			}
			else if( newvalue is SchemaString ) 
			{
				Parse( newvalue.ToString() );
			}
			else
				throw new TypesIncompatibleException( newvalue, this );

		}

		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return ToDateString();
		}

		public static SchemaDate Now
		{
			get
			{
				DateTime d = DateTime.Now;
				return new SchemaDate( d.Year, d.Month, d.Second );
			}
		}

		#region Implemented interfaces
		// ISchemaType

		// System.ICloneable
		public override object Clone()
		{
			return new SchemaDate(this);
		}

		// SchemaCalendarBase
		public override ECalendarTypes CalendarType()
		{
			return ECalendarTypes.Date;
		}

		public override SchemaDateTime DateTimeValue()
		{
			return new SchemaDateTime( myValue.Year, myValue.Month, myValue.Day);
		}

		public override SchemaDate DateValue()
		{
			return (SchemaDate)Clone();
		}

		public override SchemaTime TimeValue()
		{
			throw new TypesIncompatibleException(this, new SchemaTime());
		}

		#endregion //Implemented interfaces
	}

	public class SchemaTime : SchemaCalendarBase
	{
		#region Constructors
		public SchemaTime()
			: base()
		{
		}

		public SchemaTime(SchemaTime obj)
			: base( obj )
		{
		}

		public SchemaTime(DateTime newvalue)
			: base( newvalue )
		{
		}

		public SchemaTime(int newhour, int newminute, int newsecond, double newpartsecond, int newoffsetTZ)
		{
			DateTime dt = DateTime.Now;
			myValue = new DateTime( dt.Year, dt.Month, dt.Day, newhour, newminute, newsecond, (int)(newpartsecond*100.0));
			eTZ = ETZ.Offset;
			offsetTZ = newoffsetTZ;
			isEmpty = false;
		}

		public SchemaTime(int newhour, int newminute, int newsecond, double newpartsecond)
		{
			DateTime dt = DateTime.Now;
			myValue = new DateTime( dt.Year, dt.Month, dt.Day, newhour, newminute, newsecond, (int)(newpartsecond*100.0));
			eTZ = ETZ.Missing;
			offsetTZ = 0;
			isEmpty = false;
		}

		public SchemaTime(int newhour, int newminute, int newsecond)
		{
			DateTime dt = DateTime.Now;
			myValue = new DateTime( dt.Year, dt.Month, dt.Day, newhour, newminute, newsecond);
			eTZ = ETZ.Missing;
			offsetTZ = 0;
			isEmpty = false;
		}

		public SchemaTime(string newvalue)
		{
			Parse( newvalue );
		}

		public SchemaTime( ISchemaType obj )
		{
			Assign( obj );
		}


		#endregion //Constructors

		#region Get, Set
		public void Parse(string newvalue)
		{
			if( newvalue == null )
			{
				Reset();
				isEmpty = true;
				isNull = true;
				return;
			}
			ParseTime( newvalue );
			isEmpty = false;
			isNull = false;
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null || newvalue.IsEmpty() )
			{
				Reset();
				isEmpty = true;
				isNull = true;
				return;
			}
			isEmpty = false;
			isNull = false;
			if( newvalue is SchemaDateTime )
			{
				DateTime dtNow = DateTime.Now;
				DateTime dt = ((SchemaDateTime)newvalue).Value;
				myValue = new DateTime( dtNow.Year, dtNow.Month, dtNow.Day, dt.Hour, dt.Minute, dt.Second, dt.Millisecond );
				eTZ = ((SchemaDateTime)newvalue).HasTimezone;
			}
			else if( newvalue is SchemaTime )
			{
				DateTime dtNow = DateTime.Now;
				DateTime dt = ((SchemaTime)newvalue).Value;
				myValue = new DateTime( dtNow.Year, dtNow.Month, dtNow.Day, dt.Hour, dt.Minute, dt.Second, dt.Millisecond );
				eTZ = ((SchemaTime)newvalue).HasTimezone;
			}
			else if( newvalue is SchemaString )
				Parse( newvalue.ToString() );
			else
				throw new TypesIncompatibleException(newvalue, this);
		}
		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return ToTimeString();
		}

		public static SchemaTime Now
		{
			get
			{
				DateTime t = DateTime.Now;
				return new SchemaTime(t.Hour, t.Minute, t.Second, t.Millisecond * 1000.0);
			}
		}

		#region Implemented interfaces
		// ISchemaType

		// System.ICloneable
		public override object Clone()
		{
			return new SchemaTime(this);
		}
	
		// SchemaCalendarBase
		public override ECalendarTypes CalendarType()
		{
			return ECalendarTypes.Time;
		}

		public override SchemaDateTime DateTimeValue()
		{
			throw new TypesIncompatibleException(this, new SchemaDateTime());
		}

		public override SchemaDate DateValue()
		{
			throw new TypesIncompatibleException(this, new SchemaDateTime());
		}

		public override SchemaTime TimeValue()
		{
			return (SchemaTime)Clone();
		}

		#endregion //Implemented interfaces
	}

	public class SchemaDuration : ISchemaTypeCalendar
	{
		protected TimeSpan myValue = new TimeSpan(0);
		protected int months = 0;
		protected int years = 0;
		protected bool isEmpty = true;
		protected bool isNull = true;

		#region Constructors
		public SchemaDuration()
		{
			isNull = false;
		}

		public SchemaDuration(SchemaDuration obj)
		{
			myValue = obj.myValue;
			months = obj.months;
			years = obj.years;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaDuration(TimeSpan newvalue)
		{
			myValue = new TimeSpan(newvalue.Days % 31, newvalue.Hours, newvalue.Minutes, newvalue.Seconds, newvalue.Milliseconds);
			months = (newvalue.Days / 31) % 12;
			years = newvalue.Days / 31 / 12;
			isEmpty = false;
			isNull = false;
		}

		public SchemaDuration(long ticks)
		{
			myValue = new TimeSpan( ticks );
		}

		public SchemaDuration(int newyears, int newmonths, int days, int hours, int minutes, int seconds, double partseconds, bool bnegative)
		{
			years = newyears;
			months = newmonths;
			myValue = new TimeSpan( days, hours, minutes, seconds, (int)(partseconds * 1000.0) );
			isEmpty = isNull = false;
			if( bnegative )
			{
				myValue = -myValue;
				years = -years;
				months = -months;
			}
		}

		public SchemaDuration(string newvalue)
		{
			Parse( newvalue );
		}

		public SchemaDuration(ISchemaType obj)
		{
			Assign( obj );
		}

	#endregion //Constructors

		#region Get, Set
		public TimeSpan Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = false;
				isNull = false;
			}
		}
		public int Years
		{
			get
			{
				return years;
			}
			set
			{
				years = value;
				isEmpty = false;
				isNull = false;
			}
		}
		public int Months
		{
			get
			{
				return months;
			}
			set
			{
				months = value;
				isEmpty = false;
				isNull = false;
			}
		}

		public void Parse( string newvalue )
		{
			bool bNegative = false;
			int day = 0;
			int hour = 0;
			int minute = 0;
			int second = 0;
			double partsecond = 0.0;

			int nStart = newvalue.IndexOf("P");
			if (nStart < 0)
				throw new StringParseException("P expected", 0);
			if (nStart > 0 &&
				newvalue.Substring(nStart - 1, 1).CompareTo("-") == 0)
				bNegative = true;
			int nEnd = newvalue.IndexOf("Y", nStart + 1);
			int nLastEnd = nEnd;
			int nTPos = newvalue.IndexOf("T", nStart + 1);
			nLastEnd = (nTPos > nLastEnd ? nTPos : nLastEnd);
			try 
			{
				if (nEnd > nStart) 
				{
					years = Convert.ToInt32(newvalue.Substring(nStart + 1, nEnd - nStart - 1));
					nStart = nEnd;
				}
				else
					years = 0;

				nEnd = newvalue.IndexOf("M", nStart + 1);
				nLastEnd = (nEnd > nLastEnd ? nEnd : nLastEnd);
				if ( (nEnd > nStart) && (nTPos == -1 || nEnd < nTPos)) 
				{
					months = Convert.ToInt32(newvalue.Substring(nStart + 1, nEnd - nStart - 1));
					nStart = nEnd;
				}
				else
					months = 0;

				nEnd = newvalue.IndexOf("D", nStart + 1);
				nLastEnd = (nEnd > nLastEnd ? nEnd : nLastEnd);
				if (nEnd > nStart) 
				{
					day = Convert.ToInt32(newvalue.Substring(nStart + 1, nEnd - nStart - 1));
					nStart = nEnd;
				}

				if (nTPos > -1) 
				{
					nStart = nTPos;
					nEnd = newvalue.IndexOf("H", nStart + 1);
					nLastEnd = (nEnd > nLastEnd ? nEnd : nLastEnd);
					if (nEnd > nStart) 
					{
						hour = Convert.ToInt32(newvalue.Substring(nStart + 1, nEnd - nStart - 1));
						nStart = nEnd;
					}

					nEnd = newvalue.IndexOf("M", nStart + 1);
					nLastEnd = (nEnd > nLastEnd ? nEnd : nLastEnd);
					if (nEnd > nStart) 
					{
						minute = Convert.ToInt32(newvalue.Substring(nStart + 1, nEnd - nStart - 1));
						nStart = nEnd;
					}

					int nComma = newvalue.IndexOf(".", nStart + 1);
					nEnd = newvalue.IndexOf("S", nStart + 1);
					nLastEnd = (nEnd > nLastEnd ? nEnd : nLastEnd);
					if (nComma == -1 && nEnd > nStart)
						second = Convert.ToInt32(newvalue.Substring(nStart + 1, nEnd - nStart - 1));
					else if (nComma > nStart && nEnd > nComma) 
					{
						second = Convert.ToInt32(newvalue.Substring(nStart + 1, nComma - nStart - 1));
						partsecond = Convert.ToDouble("0." + newvalue.Substring(nComma + 1, nEnd - nComma - 1), CultureInfo.InvariantCulture );
					}
				}
				else
					nLastEnd = (nLastEnd>-1 ? nLastEnd : 0);
			}
			catch (FormatException ) 
			{
				throw new StringParseException("invalid duration format", 2);
			}
			if ((nLastEnd+1) < newvalue.Length)
				throw new StringParseException( "Invalid characters after the duration string", 2);
			if (years < 0 || months < 0 || day < 0 || hour < 0 || minute < 0 || second < 0 || partsecond < 0)
				throw new StringParseException(
					"no negative values allowed in parts. Use '-' before 'P'.", 3);
			myValue = new TimeSpan(day, hour, minute, second, (int)(partsecond*1000.0) );
			if( bNegative )
			{
				myValue = -myValue;
				months = -months;
				years = -years;
			}
			isEmpty = false;
			isNull = false;
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null || newvalue.IsEmpty() )
			{
				myValue = new TimeSpan(0);
				months = 0;
				years = 0;
				isEmpty = true;
				isNull = true;
				return;
			}
			isEmpty = false;
			if( newvalue is SchemaDuration )
			{
				myValue = ((SchemaDuration)newvalue).myValue;
				months = ((SchemaDuration)newvalue).months;
				years = ((SchemaDuration)newvalue).years;
				isEmpty = ((SchemaDuration)newvalue).isEmpty;
				isNull = ((SchemaDuration)newvalue).isNull;
			}
			else if( newvalue is SchemaString )
				Parse( newvalue.ToString() );
			else
				throw new TypesIncompatibleException( newvalue, this );
		}

		#endregion // Get, Set

		public override string ToString()
		{
			if (isEmpty)
				return "";
			string s = "";
			if (myValue.Ticks < 0 )
				s += "-";
			s += "P";
			if (years != 0) 
				s += Math.Abs(years).ToString() + "Y";
			if (months != 0) 
				s += Math.Abs(months).ToString() + "M";
			if (myValue.Days != 0) 
				s += Math.Abs(myValue.Days).ToString() + "D";
			double partsecond = (Math.Abs(myValue.Ticks) / 10000000.0) % 1.0;
			if (myValue.Hours!=0 || myValue.Minutes!=0 || myValue.Seconds!=0 || partsecond>0.0 )
			{
				s += "T";
				if (myValue.Hours != 0) 
					s += Math.Abs(myValue.Hours).ToString() + "H";
				if (myValue.Minutes != 0) 
					s += Math.Abs(myValue.Minutes).ToString() + "M";
				if (myValue.Seconds != 0)
					s += Math.Abs(myValue.Seconds).ToString("#0");
				if (partsecond > 0.0 && partsecond < 1.0) 
				{
					string sPartSecond = partsecond.ToString("0.##########");
					s += "." + sPartSecond.Substring(2, sPartSecond.Length-2);
				}
				if (myValue.Seconds != 0 || (partsecond > 0 && partsecond < 1))
					s += "S";
			}
			return s;
		}

		public bool IsNegative()
		{
			return ( myValue.Ticks < 0 );
		}


		#region Implemented interfaces
		// System.IComparable
		public override int GetHashCode()
		{
			return myValue.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			if (!(obj is SchemaDuration))
				return false;
			SchemaDuration dur = (SchemaDuration)obj;
			if( myValue != dur.myValue )
				return false;
			if( months != dur.months )
				return false;
			if( years != dur.years )
				return false;
			return true;
		}

		public static bool operator==(SchemaDuration obj1, SchemaDuration obj2)
		{
			if( (obj1.myValue == obj2.myValue)  &&
				(obj1.months == obj2.months)  &&
				(obj1.years == obj2.years) )
				return true;
			return false;
		}

		public static bool operator!=(SchemaDuration obj1, SchemaDuration obj2)
		{
			return !(obj1 == obj2);
		}

		public int CompareTo(object newvalue)
		{
			SchemaDuration obj = (SchemaDuration)newvalue;
			if( years > obj.years )
				return 1;
			if( years < obj.years )
				return -1;
			if( months > obj.months )
				return 1;
			if( months < obj.months )
				return -1;
			return myValue.CompareTo(((SchemaDuration)obj).myValue);
		}

		// System.ICloneable
		public object Clone()
		{
			return new SchemaDuration(this);
		}

		// ISchemaType
		public bool BoolValue()
		{
			return myValue.Ticks != 0;
		}

		public bool IsEmpty()
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
			if( bIsEmpty )
				myValue = TimeSpan.Zero;
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
			if( bIsNull )
				SetEmpty(true);
		}


		// ISchemaTypeCalendar
		public ECalendarTypes CalendarType()
		{
			return ECalendarTypes.Duration;
		}

		public SchemaDateTime DateTimeValue()
		{
			throw new TypesIncompatibleException(this, new SchemaDateTime());
		}

		public SchemaDate DateValue()
		{
			throw new TypesIncompatibleException(this, new SchemaDateTime());
		}

		public SchemaTime TimeValue()
		{
			throw new TypesIncompatibleException(this, new SchemaDateTime());
		}

		public SchemaDuration DurationValue()
		{
			return (SchemaDuration)Clone();
		}

		#endregion // Implemented interfaces
	}

	public class SchemaBase64Binary : SchemaBinaryBase
	{
		#region Constructors
		public SchemaBase64Binary()
			: base()
		{
		}

		public SchemaBase64Binary(SchemaBase64Binary obj)
			: base( (SchemaBinaryBase)obj )
		{
		}

		public SchemaBase64Binary(byte[] Value)
			: base( Value )
		{
		}

		public SchemaBase64Binary(string newvalue)
		{
			Parse( newvalue );
		}

		public SchemaBase64Binary(ISchemaType obj)
		{
			Assign( obj );
		}


		#endregion //Constructors;

		#region Get, Set
		public override void Parse( string newvalue )
		{
			string sValue = "";
			for( int i=0; i < newvalue.Length; i++ )
			{
				char c = newvalue[i];

				if( System.Char.IsLetterOrDigit( c ) || c == '+' || c == '/' )
					sValue += c;
			}

			for( int i = sValue.Length % 4; i != 0 && i < 4; i++ )
				sValue += "="; // concat pad-chars up to a complete base64 number
			// convert to array of bytes

			myValue = Convert.FromBase64String( sValue );
			isEmpty = false;
			isNull = false;
		}
		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty || (myValue == null) )
				return "";
			string sResult = Convert.ToBase64String( myValue );
			for( int i = 76; i < sResult.Length; i += 77 )
				sResult = sResult.Substring(0,i) + "\n" + sResult.Substring(i, sResult.Length-i );
			return sResult;
		}

		#region Implemented interfaces
		// ISchemaType

		// System.ICloneable
		public override object Clone()
		{
			return new SchemaBase64Binary(this);
		}

		// SchemaCalendarBase
		public override EBinaryTypes BinaryType()
		{
			return EBinaryTypes.Base64;
		}
		#endregion // Implemented interfaces
	}

	public class SchemaHexBinary : SchemaBinaryBase
	{
		protected static char[] s_cEncode = new char[16]
		{
			'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
		};
		protected static sbyte[] s_cDecode = new sbyte[256]
		{
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			0,	 1,	 2,	 3,	 4,	 5,	 6,	 7,	 8,	 9,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	10,	11,	12,	13,	14,	15,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	10,	11,	12,	13,	14,	15,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
			-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1
		};

		#region Constructors
		public SchemaHexBinary()
			: base()
		{
		}

		public SchemaHexBinary(SchemaHexBinary obj)
			: base( (SchemaBinaryBase)obj )
		{
		}

		public SchemaHexBinary(byte[] Value)
			: base( Value )
		{
		}

		public SchemaHexBinary(string newvalue)
		{
			Parse( newvalue );
		}

		public SchemaHexBinary(ISchemaType obj)
		{
			Assign( obj );
		}

		#endregion //Constructors;

		#region Get, Set
		public override void Parse( string newvalue )
		{
			char[] cSrc = newvalue.ToCharArray();
			myValue = new byte[ cSrc.Length / 2 ];
			int nSrcIndex = 0;
			int nTarIndex = 0;
			while( nSrcIndex < cSrc.Length )
			{
				sbyte c = s_cDecode[ cSrc[ nSrcIndex++ ] ];
				if( c != -1 )
				{
					myValue[ nTarIndex >> 1 ] |= (byte)( (nTarIndex & 1) == 1 ? c : (c << 4) );
					nTarIndex++;
				}
			}
			isEmpty = false;
			isNull = false;
		}
		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			char[] cResult = new char[ myValue.Length << 1 ];
			for( int i = 0; i < myValue.Length; i++ )
			{
				cResult[ i << 1 ] = s_cEncode[ (myValue[i] >> 4) & 15 ];
				cResult[ (i << 1) + 1 ] = s_cEncode[ myValue[i] & 15 ];
			}
			return new String( cResult );
		}

		#region Implemented interfaces
		// ISchemaType

		// System.ICloneable
		public override object Clone()
		{
			return new SchemaHexBinary(this);
		}

		// SchemaCalendarBase
		public override EBinaryTypes BinaryType()
		{
			return EBinaryTypes.Hex;
		}
		#endregion Implemented interfaces
	}


	public class SchemaString : ISchemaType , ISchemaTypeCalendar, ISchemaTypeNumber
	{
		public string myValue = "";
		public bool isEmpty = true;
		public bool isNull = true;

		#region Constructors
		public SchemaString()
		{
			isNull = false;
		}

		public SchemaString(SchemaString obj)
		{
			myValue = obj.myValue;
			isEmpty = obj.isEmpty;
			isNull = obj.isNull;
		}

		public SchemaString(string newvalue)
		{
			myValue = newvalue;
			isEmpty = (newvalue.Length == 0 );
			isNull = false;
		}

		public SchemaString( ISchemaType obj )
		{
			Assign( obj );
		}

		#endregion Constructors

		#region Get, Set
		public string Value
		{
			get
			{
				return myValue;
			}
			set
			{
				myValue = value;
				isEmpty = (myValue.Length == 0 );
				isNull = false;
			}
		}

		public void Parse(string newvalue)
		{
			myValue = newvalue;
			isEmpty = (myValue.Length == 0 );
			isNull = false;
		}

		public void Assign( ISchemaType newvalue )
		{
			if( newvalue == null || newvalue.IsEmpty() ) 
			{
				isEmpty = true;
				isNull = true;
				myValue = "";
				return;
			}
			myValue = newvalue.ToString();
			isEmpty = (myValue.Length == 0 );
			isNull = false;
		}

		#endregion // Get, Set

		public override string ToString()
		{
			if( isEmpty )
				return "";
			return myValue;
		}

		public bool IsValueNumeric() 
		{
			try 
			{
				decimal tmp = Convert.ToDecimal(myValue, CultureInfo.InvariantCulture);
			}
			catch (FormatException) 
			{
				return false;
			}
			return true;
		}


		#region Implemented interfaces
		// System.Comparable
		public override int GetHashCode()
		{
			return myValue.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
				return false;
			if (!(obj is SchemaString))
				return false;
			return myValue == ((SchemaString)obj).myValue;
		}

		public static bool operator==(SchemaString obj1, SchemaString obj2)
		{
			return obj1.myValue == obj2.myValue;
		}

		public static bool operator!=(SchemaString obj1, SchemaString obj2)
		{
			return obj1.myValue != obj2.myValue;
		}

		public int CompareTo(object obj)
		{
			return myValue.CompareTo(((SchemaString)obj).myValue);
		}

		// System.ICloneable
		public object Clone()
		{
			return new SchemaString(myValue);
		}

		// ISchemaType
		public bool BoolValue()
		{
			if( myValue==null || myValue.Length==0 || myValue.ToLower().CompareTo("false")==0 )
				return false;
			if (IsValueNumeric())
				return DecimalValue().CompareTo(0.0m) != 0;
			return true;
		}

		public bool IsEmpty()
		{
			return isEmpty;
		}

		public void SetEmpty( bool bIsEmpty )
		{
			isEmpty = bIsEmpty;
			if( bIsEmpty )
				myValue = "";
		}

		public bool IsNull()
		{
			return isNull;
		}

		public void SetNull( bool bIsNull )
		{
			isNull = bIsNull;
			if( bIsNull )
				SetEmpty(true);
		}

		// ISchemaTypeNumber
		public ENumericTypes NumericType()
		{
			return ENumericTypes.ValueDecimal;
		}

		public int IntValue()
		{
			if( myValue=="" )
				return 0;
			try
			{
				return Convert.ToInt32( myValue );
			}
			catch( FormatException )
			{
				throw new ValuesNotConvertableException(this, new SchemaInt());
			}
		}

		public long LongValue()
		{
			if( myValue=="" )
				return 0;
			try
			{
				return Convert.ToInt64( myValue );
			}
			catch( FormatException )
			{
				throw new ValuesNotConvertableException(this, new SchemaLong());
			}
		}

		public double DoubleValue()
		{
			if( myValue=="" )
				return 0.0;
			try
			{
				return Convert.ToDouble( myValue, CultureInfo.InvariantCulture );
			}
			catch( FormatException )
			{
				throw new ValuesNotConvertableException(this, new SchemaDouble());
			}
		}

		public decimal DecimalValue()
		{
			if( myValue=="" )
				return 0;
			try
			{
				return Convert.ToDecimal( myValue, CultureInfo.InvariantCulture );
			}
			catch( FormatException )
			{
				throw new ValuesNotConvertableException(this, new SchemaDecimal());
			}
		}

		// ISchemaTypeCalendar
		public ECalendarTypes CalendarType()
		{
			return ECalendarTypes.Undefined;
		}

		public SchemaDateTime DateTimeValue()
		{
			try
			{
				return new SchemaDateTime( myValue );
			}
			catch( StringParseException )
			{
				throw new ValuesNotConvertableException(this, new SchemaDateTime() );
			}
		}

		public SchemaDate DateValue()
		{
			try
			{
				return new SchemaDate( myValue );
			}
			catch( StringParseException )
			{
				throw new ValuesNotConvertableException(this, new SchemaDate() );
			}
		}

		public SchemaTime TimeValue()
		{
			try
			{
				return new SchemaTime( myValue );
			}
			catch( StringParseException )
			{
				throw new ValuesNotConvertableException(this, new SchemaTime() );
			}
		}

		public SchemaDuration DurationValue()
		{
			try
			{
				return new SchemaDuration( myValue );
			}
			catch( StringParseException )
			{
				throw new ValuesNotConvertableException(this, new SchemaDuration() );
			}
		}

		#endregion // Implemented interfaces
	}
	#endregion // Schema Types
}
