//
// Type_ImageLayer.cs.cs
//
// This file was generated by XMLSpy 2005 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//


using System;
using System.Collections;
using System.Xml;
using Altova.Types;

namespace LayerSet
{
	public class Type_ImageLayer : Altova.Xml.Node
	{
		#region Forward constructors
		public Type_ImageLayer() : base() { SetCollectionParents(); }
		public Type_ImageLayer(XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public Type_ImageLayer(XmlNode node) : base(node) { SetCollectionParents(); }
		public Type_ImageLayer(Altova.Xml.Node node) : base(node) { SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{

			for (int i = 0; i < DomChildCount(NodeType.Attribute, "", "ShowAtStartup"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "ShowAtStartup", i);
				InternalAdjustPrefix(DOMNode, false);
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "Name"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Name", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "DistanceAboveSurface"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "DistanceAboveSurface", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "BoundingBox"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "BoundingBox", i);
				InternalAdjustPrefix(DOMNode, true);
				new Type_LatLonBoundingBox2(DOMNode).AdjustPrefix();
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "TexturePath"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "TexturePath", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "Opacity"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Opacity", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "TerrainMapped"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "TerrainMapped", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "TransparencyColor"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "TransparencyColor", i);
				InternalAdjustPrefix(DOMNode, true);
				new Type_RGBColor2(DOMNode).AdjustPrefix();
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "LegendImagePath"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "LegendImagePath", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "ExtendedInformation"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "ExtendedInformation", i);
				InternalAdjustPrefix(DOMNode, true);
				new Type_ExtendedInformation(DOMNode).AdjustPrefix();
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "TransparentColor"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "TransparentColor", i);
				InternalAdjustPrefix(DOMNode, true);
				new Type_RGBColor2(DOMNode).AdjustPrefix();
			}
		}


		#region ShowAtStartup accessor methods
		public int GetShowAtStartupMinCount()
		{
			return 1;
		}

		public int ShowAtStartupMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetShowAtStartupMaxCount()
		{
			return 1;
		}

		public int ShowAtStartupMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetShowAtStartupCount()
		{
			return DomChildCount(NodeType.Attribute, "", "ShowAtStartup");
		}

		public int ShowAtStartupCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "ShowAtStartup");
			}
		}

		public bool HasShowAtStartup()
		{
			return HasDomChild(NodeType.Attribute, "", "ShowAtStartup");
		}

		public SchemaBoolean GetShowAtStartupAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "ShowAtStartup", index)));
		}

		public XmlNode GetStartingShowAtStartupCursor()
		{
			return GetDomFirstChild( NodeType.Attribute, "", "ShowAtStartup" );
		}

		public XmlNode GetAdvancedShowAtStartupCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Attribute, "", "ShowAtStartup", curNode );
		}

		public SchemaBoolean GetShowAtStartupValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaBoolean( curNode.Value );
		}


		public SchemaBoolean GetShowAtStartup()
		{
			return GetShowAtStartupAt(0);
		}

		public SchemaBoolean ShowAtStartup
		{
			get
			{
				return GetShowAtStartupAt(0);
			}
		}

		public void RemoveShowAtStartupAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "ShowAtStartup", index);
		}

		public void RemoveShowAtStartup()
		{
			while (HasShowAtStartup())
				RemoveShowAtStartupAt(0);
		}

		public void AddShowAtStartup(SchemaBoolean newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "ShowAtStartup", newValue.ToString());
		}

		public void InsertShowAtStartupAt(SchemaBoolean newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "ShowAtStartup", index, newValue.ToString());
		}

		public void ReplaceShowAtStartupAt(SchemaBoolean newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "ShowAtStartup", index, newValue.ToString());
		}
		#endregion // ShowAtStartup accessor methods

		#region ShowAtStartup collection
        public ShowAtStartupCollection	MyShowAtStartups = new ShowAtStartupCollection( );

        public class ShowAtStartupCollection: IEnumerable
        {
            Type_ImageLayer parent;
            public Type_ImageLayer Parent
			{
				set
				{
					parent = value;
				}
			}
			public ShowAtStartupEnumerator GetEnumerator() 
			{
				return new ShowAtStartupEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ShowAtStartupEnumerator: IEnumerator 
        {
			int nIndex;
			Type_ImageLayer parent;
			public ShowAtStartupEnumerator(Type_ImageLayer par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ShowAtStartupCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(parent.GetShowAtStartupAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // ShowAtStartup collection

		#region Name accessor methods
		public int GetNameMinCount()
		{
			return 1;
		}

		public int NameMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetNameMaxCount()
		{
			return 1;
		}

		public int NameMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetNameCount()
		{
			return DomChildCount(NodeType.Element, "", "Name");
		}

		public int NameCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Name");
			}
		}

		public bool HasName()
		{
			return HasDomChild(NodeType.Element, "", "Name");
		}

		public NameType GetNameAt(int index)
		{
			return new NameType(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Name", index)));
		}

		public XmlNode GetStartingNameCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "Name" );
		}

		public XmlNode GetAdvancedNameCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "Name", curNode );
		}

		public NameType GetNameValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new NameType( curNode.InnerText );
		}


		public NameType GetName()
		{
			return GetNameAt(0);
		}

		public NameType Name
		{
			get
			{
				return GetNameAt(0);
			}
		}

		public void RemoveNameAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Name", index);
		}

		public void RemoveName()
		{
			while (HasName())
				RemoveNameAt(0);
		}

		public void AddName(NameType newValue)
		{
			AppendDomChild(NodeType.Element, "", "Name", newValue.ToString());
		}

		public void InsertNameAt(NameType newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "Name", index, newValue.ToString());
		}

		public void ReplaceNameAt(NameType newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Name", index, newValue.ToString());
		}
		#endregion // Name accessor methods

		#region Name collection
        public NameCollection	MyNames = new NameCollection( );

        public class NameCollection: IEnumerable
        {
            Type_ImageLayer parent;
            public Type_ImageLayer Parent
			{
				set
				{
					parent = value;
				}
			}
			public NameEnumerator GetEnumerator() 
			{
				return new NameEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class NameEnumerator: IEnumerator 
        {
			int nIndex;
			Type_ImageLayer parent;
			public NameEnumerator(Type_ImageLayer par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.NameCount );
			}
			public NameType  Current 
			{
				get 
				{
					return(parent.GetNameAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Name collection

		#region DistanceAboveSurface accessor methods
		public int GetDistanceAboveSurfaceMinCount()
		{
			return 1;
		}

		public int DistanceAboveSurfaceMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetDistanceAboveSurfaceMaxCount()
		{
			return 1;
		}

		public int DistanceAboveSurfaceMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetDistanceAboveSurfaceCount()
		{
			return DomChildCount(NodeType.Element, "", "DistanceAboveSurface");
		}

		public int DistanceAboveSurfaceCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "DistanceAboveSurface");
			}
		}

		public bool HasDistanceAboveSurface()
		{
			return HasDomChild(NodeType.Element, "", "DistanceAboveSurface");
		}

		public SchemaDecimal GetDistanceAboveSurfaceAt(int index)
		{
			return new SchemaDecimal(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "DistanceAboveSurface", index)));
		}

		public XmlNode GetStartingDistanceAboveSurfaceCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "DistanceAboveSurface" );
		}

		public XmlNode GetAdvancedDistanceAboveSurfaceCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "DistanceAboveSurface", curNode );
		}

		public SchemaDecimal GetDistanceAboveSurfaceValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaDecimal( curNode.InnerText );
		}


		public SchemaDecimal GetDistanceAboveSurface()
		{
			return GetDistanceAboveSurfaceAt(0);
		}

		public SchemaDecimal DistanceAboveSurface
		{
			get
			{
				return GetDistanceAboveSurfaceAt(0);
			}
		}

		public void RemoveDistanceAboveSurfaceAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "DistanceAboveSurface", index);
		}

		public void RemoveDistanceAboveSurface()
		{
			while (HasDistanceAboveSurface())
				RemoveDistanceAboveSurfaceAt(0);
		}

		public void AddDistanceAboveSurface(SchemaDecimal newValue)
		{
			AppendDomChild(NodeType.Element, "", "DistanceAboveSurface", newValue.ToString());
		}

		public void InsertDistanceAboveSurfaceAt(SchemaDecimal newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "DistanceAboveSurface", index, newValue.ToString());
		}

		public void ReplaceDistanceAboveSurfaceAt(SchemaDecimal newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "DistanceAboveSurface", index, newValue.ToString());
		}
		#endregion // DistanceAboveSurface accessor methods

		#region DistanceAboveSurface collection
        public DistanceAboveSurfaceCollection	MyDistanceAboveSurfaces = new DistanceAboveSurfaceCollection( );

        public class DistanceAboveSurfaceCollection: IEnumerable
        {
            Type_ImageLayer parent;
            public Type_ImageLayer Parent
			{
				set
				{
					parent = value;
				}
			}
			public DistanceAboveSurfaceEnumerator GetEnumerator() 
			{
				return new DistanceAboveSurfaceEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class DistanceAboveSurfaceEnumerator: IEnumerator 
        {
			int nIndex;
			Type_ImageLayer parent;
			public DistanceAboveSurfaceEnumerator(Type_ImageLayer par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.DistanceAboveSurfaceCount );
			}
			public SchemaDecimal  Current 
			{
				get 
				{
					return(parent.GetDistanceAboveSurfaceAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // DistanceAboveSurface collection

		#region BoundingBox accessor methods
		public int GetBoundingBoxMinCount()
		{
			return 1;
		}

		public int BoundingBoxMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetBoundingBoxMaxCount()
		{
			return 1;
		}

		public int BoundingBoxMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetBoundingBoxCount()
		{
			return DomChildCount(NodeType.Element, "", "BoundingBox");
		}

		public int BoundingBoxCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "BoundingBox");
			}
		}

		public bool HasBoundingBox()
		{
			return HasDomChild(NodeType.Element, "", "BoundingBox");
		}

		public Type_LatLonBoundingBox2 GetBoundingBoxAt(int index)
		{
			return new Type_LatLonBoundingBox2(GetDomChildAt(NodeType.Element, "", "BoundingBox", index));
		}

		public XmlNode GetStartingBoundingBoxCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "BoundingBox" );
		}

		public XmlNode GetAdvancedBoundingBoxCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "BoundingBox", curNode );
		}

		public Type_LatLonBoundingBox2 GetBoundingBoxValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new Type_LatLonBoundingBox2( curNode );
		}


		public Type_LatLonBoundingBox2 GetBoundingBox()
		{
			return GetBoundingBoxAt(0);
		}

		public Type_LatLonBoundingBox2 BoundingBox
		{
			get
			{
				return GetBoundingBoxAt(0);
			}
		}

		public void RemoveBoundingBoxAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "BoundingBox", index);
		}

		public void RemoveBoundingBox()
		{
			while (HasBoundingBox())
				RemoveBoundingBoxAt(0);
		}

		public void AddBoundingBox(Type_LatLonBoundingBox2 newValue)
		{
			AppendDomElement("", "BoundingBox", newValue);
		}

		public void InsertBoundingBoxAt(Type_LatLonBoundingBox2 newValue, int index)
		{
			InsertDomElementAt("", "BoundingBox", index, newValue);
		}

		public void ReplaceBoundingBoxAt(Type_LatLonBoundingBox2 newValue, int index)
		{
			ReplaceDomElementAt("", "BoundingBox", index, newValue);
		}
		#endregion // BoundingBox accessor methods

		#region BoundingBox collection
        public BoundingBoxCollection	MyBoundingBoxs = new BoundingBoxCollection( );

        public class BoundingBoxCollection: IEnumerable
        {
            Type_ImageLayer parent;
            public Type_ImageLayer Parent
			{
				set
				{
					parent = value;
				}
			}
			public BoundingBoxEnumerator GetEnumerator() 
			{
				return new BoundingBoxEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class BoundingBoxEnumerator: IEnumerator 
        {
			int nIndex;
			Type_ImageLayer parent;
			public BoundingBoxEnumerator(Type_ImageLayer par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.BoundingBoxCount );
			}
			public Type_LatLonBoundingBox2  Current 
			{
				get 
				{
					return(parent.GetBoundingBoxAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // BoundingBox collection

		#region TexturePath accessor methods
		public int GetTexturePathMinCount()
		{
			return 1;
		}

		public int TexturePathMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetTexturePathMaxCount()
		{
			return 1;
		}

		public int TexturePathMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetTexturePathCount()
		{
			return DomChildCount(NodeType.Element, "", "TexturePath");
		}

		public int TexturePathCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "TexturePath");
			}
		}

		public bool HasTexturePath()
		{
			return HasDomChild(NodeType.Element, "", "TexturePath");
		}

		public SchemaString GetTexturePathAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "TexturePath", index)));
		}

		public XmlNode GetStartingTexturePathCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "TexturePath" );
		}

		public XmlNode GetAdvancedTexturePathCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "TexturePath", curNode );
		}

		public SchemaString GetTexturePathValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetTexturePath()
		{
			return GetTexturePathAt(0);
		}

		public SchemaString TexturePath
		{
			get
			{
				return GetTexturePathAt(0);
			}
		}

		public void RemoveTexturePathAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "TexturePath", index);
		}

		public void RemoveTexturePath()
		{
			while (HasTexturePath())
				RemoveTexturePathAt(0);
		}

		public void AddTexturePath(SchemaString newValue)
		{
			AppendDomChild(NodeType.Element, "", "TexturePath", newValue.ToString());
		}

		public void InsertTexturePathAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "TexturePath", index, newValue.ToString());
		}

		public void ReplaceTexturePathAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "TexturePath", index, newValue.ToString());
		}
		#endregion // TexturePath accessor methods

		#region TexturePath collection
        public TexturePathCollection	MyTexturePaths = new TexturePathCollection( );

        public class TexturePathCollection: IEnumerable
        {
            Type_ImageLayer parent;
            public Type_ImageLayer Parent
			{
				set
				{
					parent = value;
				}
			}
			public TexturePathEnumerator GetEnumerator() 
			{
				return new TexturePathEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class TexturePathEnumerator: IEnumerator 
        {
			int nIndex;
			Type_ImageLayer parent;
			public TexturePathEnumerator(Type_ImageLayer par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.TexturePathCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetTexturePathAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // TexturePath collection

		#region Opacity accessor methods
		public int GetOpacityMinCount()
		{
			return 1;
		}

		public int OpacityMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetOpacityMaxCount()
		{
			return 1;
		}

		public int OpacityMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetOpacityCount()
		{
			return DomChildCount(NodeType.Element, "", "Opacity");
		}

		public int OpacityCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Opacity");
			}
		}

		public bool HasOpacity()
		{
			return HasDomChild(NodeType.Element, "", "Opacity");
		}

		public OpacityType GetOpacityAt(int index)
		{
			return new OpacityType(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Opacity", index)));
		}

		public XmlNode GetStartingOpacityCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "Opacity" );
		}

		public XmlNode GetAdvancedOpacityCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "Opacity", curNode );
		}

		public OpacityType GetOpacityValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new OpacityType( curNode.InnerText );
		}


		public OpacityType GetOpacity()
		{
			return GetOpacityAt(0);
		}

		public OpacityType Opacity
		{
			get
			{
				return GetOpacityAt(0);
			}
		}

		public void RemoveOpacityAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Opacity", index);
		}

		public void RemoveOpacity()
		{
			while (HasOpacity())
				RemoveOpacityAt(0);
		}

		public void AddOpacity(OpacityType newValue)
		{
			AppendDomChild(NodeType.Element, "", "Opacity", newValue.ToString());
		}

		public void InsertOpacityAt(OpacityType newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "Opacity", index, newValue.ToString());
		}

		public void ReplaceOpacityAt(OpacityType newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Opacity", index, newValue.ToString());
		}
		#endregion // Opacity accessor methods

		#region Opacity collection
        public OpacityCollection	MyOpacitys = new OpacityCollection( );

        public class OpacityCollection: IEnumerable
        {
            Type_ImageLayer parent;
            public Type_ImageLayer Parent
			{
				set
				{
					parent = value;
				}
			}
			public OpacityEnumerator GetEnumerator() 
			{
				return new OpacityEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class OpacityEnumerator: IEnumerator 
        {
			int nIndex;
			Type_ImageLayer parent;
			public OpacityEnumerator(Type_ImageLayer par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.OpacityCount );
			}
			public OpacityType  Current 
			{
				get 
				{
					return(parent.GetOpacityAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Opacity collection

		#region TerrainMapped accessor methods
		public int GetTerrainMappedMinCount()
		{
			return 1;
		}

		public int TerrainMappedMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetTerrainMappedMaxCount()
		{
			return 1;
		}

		public int TerrainMappedMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetTerrainMappedCount()
		{
			return DomChildCount(NodeType.Element, "", "TerrainMapped");
		}

		public int TerrainMappedCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "TerrainMapped");
			}
		}

		public bool HasTerrainMapped()
		{
			return HasDomChild(NodeType.Element, "", "TerrainMapped");
		}

		public SchemaBoolean GetTerrainMappedAt(int index)
		{
			return new SchemaBoolean(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "TerrainMapped", index)));
		}

		public XmlNode GetStartingTerrainMappedCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "TerrainMapped" );
		}

		public XmlNode GetAdvancedTerrainMappedCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "TerrainMapped", curNode );
		}

		public SchemaBoolean GetTerrainMappedValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaBoolean( curNode.InnerText );
		}


		public SchemaBoolean GetTerrainMapped()
		{
			return GetTerrainMappedAt(0);
		}

		public SchemaBoolean TerrainMapped
		{
			get
			{
				return GetTerrainMappedAt(0);
			}
		}

		public void RemoveTerrainMappedAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "TerrainMapped", index);
		}

		public void RemoveTerrainMapped()
		{
			while (HasTerrainMapped())
				RemoveTerrainMappedAt(0);
		}

		public void AddTerrainMapped(SchemaBoolean newValue)
		{
			AppendDomChild(NodeType.Element, "", "TerrainMapped", newValue.ToString());
		}

		public void InsertTerrainMappedAt(SchemaBoolean newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "TerrainMapped", index, newValue.ToString());
		}

		public void ReplaceTerrainMappedAt(SchemaBoolean newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "TerrainMapped", index, newValue.ToString());
		}
		#endregion // TerrainMapped accessor methods

		#region TerrainMapped collection
        public TerrainMappedCollection	MyTerrainMappeds = new TerrainMappedCollection( );

        public class TerrainMappedCollection: IEnumerable
        {
            Type_ImageLayer parent;
            public Type_ImageLayer Parent
			{
				set
				{
					parent = value;
				}
			}
			public TerrainMappedEnumerator GetEnumerator() 
			{
				return new TerrainMappedEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class TerrainMappedEnumerator: IEnumerator 
        {
			int nIndex;
			Type_ImageLayer parent;
			public TerrainMappedEnumerator(Type_ImageLayer par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.TerrainMappedCount );
			}
			public SchemaBoolean  Current 
			{
				get 
				{
					return(parent.GetTerrainMappedAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // TerrainMapped collection

		#region TransparencyColor accessor methods
		public int GetTransparencyColorMinCount()
		{
			return 0;
		}

		public int TransparencyColorMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetTransparencyColorMaxCount()
		{
			return 1;
		}

		public int TransparencyColorMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetTransparencyColorCount()
		{
			return DomChildCount(NodeType.Element, "", "TransparencyColor");
		}

		public int TransparencyColorCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "TransparencyColor");
			}
		}

		public bool HasTransparencyColor()
		{
			return HasDomChild(NodeType.Element, "", "TransparencyColor");
		}

		public Type_RGBColor2 GetTransparencyColorAt(int index)
		{
			return new Type_RGBColor2(GetDomChildAt(NodeType.Element, "", "TransparencyColor", index));
		}

		public XmlNode GetStartingTransparencyColorCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "TransparencyColor" );
		}

		public XmlNode GetAdvancedTransparencyColorCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "TransparencyColor", curNode );
		}

		public Type_RGBColor2 GetTransparencyColorValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new Type_RGBColor2( curNode );
		}


		public Type_RGBColor2 GetTransparencyColor()
		{
			return GetTransparencyColorAt(0);
		}

		public Type_RGBColor2 TransparencyColor
		{
			get
			{
				return GetTransparencyColorAt(0);
			}
		}

		public void RemoveTransparencyColorAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "TransparencyColor", index);
		}

		public void RemoveTransparencyColor()
		{
			while (HasTransparencyColor())
				RemoveTransparencyColorAt(0);
		}

		public void AddTransparencyColor(Type_RGBColor2 newValue)
		{
			AppendDomElement("", "TransparencyColor", newValue);
		}

		public void InsertTransparencyColorAt(Type_RGBColor2 newValue, int index)
		{
			InsertDomElementAt("", "TransparencyColor", index, newValue);
		}

		public void ReplaceTransparencyColorAt(Type_RGBColor2 newValue, int index)
		{
			ReplaceDomElementAt("", "TransparencyColor", index, newValue);
		}
		#endregion // TransparencyColor accessor methods

		#region TransparencyColor collection
        public TransparencyColorCollection	MyTransparencyColors = new TransparencyColorCollection( );

        public class TransparencyColorCollection: IEnumerable
        {
            Type_ImageLayer parent;
            public Type_ImageLayer Parent
			{
				set
				{
					parent = value;
				}
			}
			public TransparencyColorEnumerator GetEnumerator() 
			{
				return new TransparencyColorEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class TransparencyColorEnumerator: IEnumerator 
        {
			int nIndex;
			Type_ImageLayer parent;
			public TransparencyColorEnumerator(Type_ImageLayer par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.TransparencyColorCount );
			}
			public Type_RGBColor2  Current 
			{
				get 
				{
					return(parent.GetTransparencyColorAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // TransparencyColor collection

		#region LegendImagePath accessor methods
		public int GetLegendImagePathMinCount()
		{
			return 0;
		}

		public int LegendImagePathMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetLegendImagePathMaxCount()
		{
			return 1;
		}

		public int LegendImagePathMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetLegendImagePathCount()
		{
			return DomChildCount(NodeType.Element, "", "LegendImagePath");
		}

		public int LegendImagePathCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "LegendImagePath");
			}
		}

		public bool HasLegendImagePath()
		{
			return HasDomChild(NodeType.Element, "", "LegendImagePath");
		}

		public SchemaString GetLegendImagePathAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "LegendImagePath", index)));
		}

		public XmlNode GetStartingLegendImagePathCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "LegendImagePath" );
		}

		public XmlNode GetAdvancedLegendImagePathCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "LegendImagePath", curNode );
		}

		public SchemaString GetLegendImagePathValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new SchemaString( curNode.InnerText );
		}


		public SchemaString GetLegendImagePath()
		{
			return GetLegendImagePathAt(0);
		}

		public SchemaString LegendImagePath
		{
			get
			{
				return GetLegendImagePathAt(0);
			}
		}

		public void RemoveLegendImagePathAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "LegendImagePath", index);
		}

		public void RemoveLegendImagePath()
		{
			while (HasLegendImagePath())
				RemoveLegendImagePathAt(0);
		}

		public void AddLegendImagePath(SchemaString newValue)
		{
			AppendDomChild(NodeType.Element, "", "LegendImagePath", newValue.ToString());
		}

		public void InsertLegendImagePathAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "LegendImagePath", index, newValue.ToString());
		}

		public void ReplaceLegendImagePathAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "LegendImagePath", index, newValue.ToString());
		}
		#endregion // LegendImagePath accessor methods

		#region LegendImagePath collection
        public LegendImagePathCollection	MyLegendImagePaths = new LegendImagePathCollection( );

        public class LegendImagePathCollection: IEnumerable
        {
            Type_ImageLayer parent;
            public Type_ImageLayer Parent
			{
				set
				{
					parent = value;
				}
			}
			public LegendImagePathEnumerator GetEnumerator() 
			{
				return new LegendImagePathEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class LegendImagePathEnumerator: IEnumerator 
        {
			int nIndex;
			Type_ImageLayer parent;
			public LegendImagePathEnumerator(Type_ImageLayer par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.LegendImagePathCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetLegendImagePathAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // LegendImagePath collection

		#region ExtendedInformation accessor methods
		public int GetExtendedInformationMinCount()
		{
			return 0;
		}

		public int ExtendedInformationMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetExtendedInformationMaxCount()
		{
			return 1;
		}

		public int ExtendedInformationMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetExtendedInformationCount()
		{
			return DomChildCount(NodeType.Element, "", "ExtendedInformation");
		}

		public int ExtendedInformationCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "ExtendedInformation");
			}
		}

		public bool HasExtendedInformation()
		{
			return HasDomChild(NodeType.Element, "", "ExtendedInformation");
		}

		public Type_ExtendedInformation GetExtendedInformationAt(int index)
		{
			return new Type_ExtendedInformation(GetDomChildAt(NodeType.Element, "", "ExtendedInformation", index));
		}

		public XmlNode GetStartingExtendedInformationCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "ExtendedInformation" );
		}

		public XmlNode GetAdvancedExtendedInformationCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "ExtendedInformation", curNode );
		}

		public Type_ExtendedInformation GetExtendedInformationValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new Type_ExtendedInformation( curNode );
		}


		public Type_ExtendedInformation GetExtendedInformation()
		{
			return GetExtendedInformationAt(0);
		}

		public Type_ExtendedInformation ExtendedInformation
		{
			get
			{
				return GetExtendedInformationAt(0);
			}
		}

		public void RemoveExtendedInformationAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "ExtendedInformation", index);
		}

		public void RemoveExtendedInformation()
		{
			while (HasExtendedInformation())
				RemoveExtendedInformationAt(0);
		}

		public void AddExtendedInformation(Type_ExtendedInformation newValue)
		{
			AppendDomElement("", "ExtendedInformation", newValue);
		}

		public void InsertExtendedInformationAt(Type_ExtendedInformation newValue, int index)
		{
			InsertDomElementAt("", "ExtendedInformation", index, newValue);
		}

		public void ReplaceExtendedInformationAt(Type_ExtendedInformation newValue, int index)
		{
			ReplaceDomElementAt("", "ExtendedInformation", index, newValue);
		}
		#endregion // ExtendedInformation accessor methods

		#region ExtendedInformation collection
        public ExtendedInformationCollection	MyExtendedInformations = new ExtendedInformationCollection( );

        public class ExtendedInformationCollection: IEnumerable
        {
            Type_ImageLayer parent;
            public Type_ImageLayer Parent
			{
				set
				{
					parent = value;
				}
			}
			public ExtendedInformationEnumerator GetEnumerator() 
			{
				return new ExtendedInformationEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ExtendedInformationEnumerator: IEnumerator 
        {
			int nIndex;
			Type_ImageLayer parent;
			public ExtendedInformationEnumerator(Type_ImageLayer par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ExtendedInformationCount );
			}
			public Type_ExtendedInformation  Current 
			{
				get 
				{
					return(parent.GetExtendedInformationAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // ExtendedInformation collection

		#region TransparentColor accessor methods
		public int GetTransparentColorMinCount()
		{
			return 0;
		}

		public int TransparentColorMinCount
		{
			get
			{
				return 0;
			}
		}

		public int GetTransparentColorMaxCount()
		{
			return 1;
		}

		public int TransparentColorMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetTransparentColorCount()
		{
			return DomChildCount(NodeType.Element, "", "TransparentColor");
		}

		public int TransparentColorCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "TransparentColor");
			}
		}

		public bool HasTransparentColor()
		{
			return HasDomChild(NodeType.Element, "", "TransparentColor");
		}

		public Type_RGBColor2 GetTransparentColorAt(int index)
		{
			return new Type_RGBColor2(GetDomChildAt(NodeType.Element, "", "TransparentColor", index));
		}

		public XmlNode GetStartingTransparentColorCursor()
		{
			return GetDomFirstChild( NodeType.Element, "", "TransparentColor" );
		}

		public XmlNode GetAdvancedTransparentColorCursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.Element, "", "TransparentColor", curNode );
		}

		public Type_RGBColor2 GetTransparentColorValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
				return new Type_RGBColor2( curNode );
		}


		public Type_RGBColor2 GetTransparentColor()
		{
			return GetTransparentColorAt(0);
		}

		public Type_RGBColor2 TransparentColor
		{
			get
			{
				return GetTransparentColorAt(0);
			}
		}

		public void RemoveTransparentColorAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "TransparentColor", index);
		}

		public void RemoveTransparentColor()
		{
			while (HasTransparentColor())
				RemoveTransparentColorAt(0);
		}

		public void AddTransparentColor(Type_RGBColor2 newValue)
		{
			AppendDomElement("", "TransparentColor", newValue);
		}

		public void InsertTransparentColorAt(Type_RGBColor2 newValue, int index)
		{
			InsertDomElementAt("", "TransparentColor", index, newValue);
		}

		public void ReplaceTransparentColorAt(Type_RGBColor2 newValue, int index)
		{
			ReplaceDomElementAt("", "TransparentColor", index, newValue);
		}
		#endregion // TransparentColor accessor methods

		#region TransparentColor collection
        public TransparentColorCollection	MyTransparentColors = new TransparentColorCollection( );

        public class TransparentColorCollection: IEnumerable
        {
            Type_ImageLayer parent;
            public Type_ImageLayer Parent
			{
				set
				{
					parent = value;
				}
			}
			public TransparentColorEnumerator GetEnumerator() 
			{
				return new TransparentColorEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class TransparentColorEnumerator: IEnumerator 
        {
			int nIndex;
			Type_ImageLayer parent;
			public TransparentColorEnumerator(Type_ImageLayer par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.TransparentColorCount );
			}
			public Type_RGBColor2  Current 
			{
				get 
				{
					return(parent.GetTransparentColorAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // TransparentColor collection

        private void SetCollectionParents()
        {
            MyShowAtStartups.Parent = this; 
            MyNames.Parent = this; 
            MyDistanceAboveSurfaces.Parent = this; 
            MyBoundingBoxs.Parent = this; 
            MyTexturePaths.Parent = this; 
            MyOpacitys.Parent = this; 
            MyTerrainMappeds.Parent = this; 
            MyTransparencyColors.Parent = this; 
            MyLegendImagePaths.Parent = this; 
            MyExtendedInformations.Parent = this; 
            MyTransparentColors.Parent = this; 
	}
}
}
